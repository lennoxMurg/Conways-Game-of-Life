# üßë‚Äçüíª Hier wird meine herangehensweise Dokumentiert

## 1. Planung und Verst√§ndnis des Problems

Bevor ich mit der eigentlichen Entwicklung begonnen habe, habe ich mich intensiv mit dem Konzept von __Conways Game of Life__ besch√§ftigt.
Dabei habe ich mir folgende Punkte erarbeitet:

- Was ist ein zellul√§rer Automat

- Wie funktionieren die vier Regeln des Game of Life

- Welche Datenstrukturen eignen sich zur Darstellung eines zweidimensionalen Gitters

- Welche Herausforderungen entstehen bei der Berechnung der Nachbarn

- Wie man Generationen effizient aktualisiert

Diese Vor√ºberlegungen waren wichtig, um eine klare Vorstellung davon zu bekommen, wie die sp√§tere Implementierung aussehen soll.

## 2. Grundger√ºst und technische Basis

Im n√§chsten Schritt habe ich die grundlegenden Strukturen des Projekts aufgebaut.
Dazu geh√∂rten:

- das Erstellen einer Tilemap, um das Spielfeld visuell darzustellen

- das Erstellen der ben√∂tigten Texturen f√ºr lebende und tote Zellen

- die Strukturierung der Projektdateien

- das Erstellung der grundlegenden Szenen in Godot

Ziel dieser Phase war es, eine stabile Basis zu schaffen, auf der ich sp√§ter die eigentliche Logik aufbauen kann.

## 3. Implementierung der Spiellogik

Nachdem das Grundger√ºst stand, habe ich mich auf die Kernfunktionalit√§t konzentriert:

- Speicherung des Spielfelds in einer geeigneten Datenstruktur

- Berechnung der Nachbarn jeder Zelle

- Anwendung der vier Regeln des Game of Life

- Erzeugung neuer Generationen

- Aktualisierung der Tilemap basierend auf dem Zustand der Zellen

- M√∂glichkeit, das Spielfeld manuell zu bearbeiten

In dieser Phase ging es vor allem darum, die Logik korrekt, nachvollziehbar und effizient umzusetzen.

## 4. Erweiterungen und Features

Nachdem die Grundlogik funktionierte, habe ich zus√§tzliche Funktionen erg√§nzt, um das Projekt benutzerfreundlicher und vollst√§ndiger zu machen:

- Start/Stop‚ÄëFunktion f√ºr die Simulation

- Anpassbare Geschwindigkeit der Simulation

- Eine generation weiter /Skip button

Diese Features waren nicht zwingend notwendig, verbessern aber die Bedienbarkeit und zeigen meine F√§higkeit, ein Projekt √ºber die Mindestanforderungen hinaus zu gestalten.

## 5. UI, HUD und Feinschliff

Zum Schluss habe ich das Benutzerinterface gestaltet und das Projekt abgerundet:

- HUD‚ÄëElemente f√ºr Steuerung und Status

- Men√ºstruktur

- klare Beschriftungen und Buttons

- optische Verbesserungen

- Aufr√§umen des Codes und Kommentieren wichtiger Stellen

Diese Phase diente dazu, das Projekt in einen pr√§sentierbaren Zustand zu bringen.
